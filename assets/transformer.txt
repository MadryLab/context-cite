
Transformer (deep learning architecture)

From Wikipedia, the free encyclopedia

"Transformer architecture" redirects here. For the design of electrical transformers, see Transformer.

This article relies excessively on references to primary sources. Please improve this article by adding secondary or tertiary sources.
Find sources: "Transformer" deep learning architecture â€“ news Â· newspapers Â· books Â· scholar Â· JSTOR (February 2023) (Learn how and when to remove this message)
Part of a series on
Machine learning
and data mining
Paradigms
Problems
Supervised learning
(classification â€¢ regression)
Clustering
Dimensionality reduction
Structured prediction
Anomaly detection
Artificial neural network
AutoencoderCognitive computingDeep learningDeepDreamFeedforward neural networkRecurrent neural network LSTMGRUESNreservoir computingRestricted Boltzmann machineGANDiffusion modelSOMConvolutional neural network U-NetTransformer VisionMambaSpiking neural networkMemtransistorElectrochemical RAM (ECRAM)
Reinforcement learning
Learning with humans
Model diagnostics
Mathematical foundations
Machine-learning venues
Related articles
vte
A transformer is a deep learning architecture developed by Google and based on the multi-head attention mechanism, proposed in a 2017 paper "Attention Is All You Need".[1] Text is converted to numerical representations called tokens, and each token is converted into a vector via looking up from a word embedding table.[1] At each layer, each token is then contextualized within the scope of the context window with other (unmasked) tokens via a parallel multi-head attention mechanism allowing the signal for key tokens to be amplified and less important tokens to be diminished. The transformer paper, published in 2017, is based on the softmax-based attention mechanism proposed by Bahdanau et. al. in 2014 for machine translation,[2][3] and the Fast Weight Controller, similar to a transformer, proposed in 1992.[4][5][6]

Transformers have the advantage of having no recurrent units, and thus requires less training time than previous recurrent neural architectures, such as long short-term memory (LSTM),[7] and its later variation has been prevalently adopted for training large language models (LLM) on large (language) datasets, such as the Wikipedia corpus and Common Crawl.[8]

This architecture is now used not only in natural language processing and computer vision,[9] but also in audio[10] and multi-modal processing. It has also led to the development of pre-trained systems, such as generative pre-trained transformers (GPTs)[11] and BERT[12] (Bidirectional Encoder Representations from Transformers).

Timeline of natural language processing models
Timeline
In 1990, the Elman network, using a recurrent neural network, encoded each word in a training set as a vector, called a word embedding, and the whole vocabulary as a vector database, allowing it to perform such tasks as sequence-predictions that are beyond the power of a simple multilayer perceptron. A shortcoming of the static embeddings was that they didn't differentiate between multiple meanings of same-spelt words.[13]
In 1992, the Fast Weight Controller was published by JÃ¼rgen Schmidhuber.[4] It learns to answer queries by programming the attention weights of another neural network through outer products of key vectors and value vectors called FROM and TO. The Fast Weight Controller was later shown to be equivalent to the unnormalized linear Transformer.[6][5][14][15] The terminology "learning internal spotlights of attention" was introduced in 1993.[16]
In 1993, the IBM alignment models were used for statistical machine translation.[17]
In 1997, a precursor of large language model, using recurrent neural networks, such as long short-term memory, was proposed.
In 2001, a one-billion-word large text corpus, scraped from the Internet, referred to as "very very large" at the time, was used for word disambiguation.[18]
In 2012, AlexNet demonstrated the effectiveness of large neural networks for image recognition, encouraging large artificial neural networks approach instead of older, statistical approaches.
In 2014, a 380M-parameter seq2seq model for machine translation using two Long short-term Memory (LSTMs) networks was proposed by Sutskever at al.[19] The architecture consists of two parts. The encoder is an LSTM that takes in a sequence of tokens and turns it into a vector. The decoder is another LSTM that converts the vector into a sequence of tokens.
In 2014, gating proved to be useful in a 130M-parameter seq2seq model, which used a simplified gated recurrent units (GRUs). Bahdanau et al[20] showed that GRUs are neither better nor worse than gated LSTMs.[21][22]
In 2014, Bahdanau et al.[23] improved the previous seq2seq model by using an "additive" kind of attention mechanism in-between two LSTM networks. It was, however, not yet the parallelizable (scaled "dot product") kind of attention, later proposed in the 2017 transformer paper.
In 2015, the relative performance of Global and Local (windowed) attention model architectures were assessed by Luong et al, a mixed attention architecture found to improve on the translations offered by Bahdanau's architecture, while the use of a local attention architecture reduced translation time.[24]
In 2016, Google Translate gradually replaced the older statistical machine translation approach with the newer neural-networks-based approach that included a seq2seq model combined by LSTM and the "additive" kind of attention mechanism. They achieved a higher level of performance than the statistical approach, which took ten years to develop, in only nine months.[25][26]
In 2017, the original (100M-sized) encoder-decoder transformer model with a faster (parallelizable or decomposable) attention mechanism was proposed in the "Attention is all you need" paper. As the model had difficulties converging, it was suggested that the learning rate should be linearly scaled up from 0 to maximal value for the first part of the training (i.e. 2% of the total number of training steps). The intent of the transformer model is to take a seq2seq model and remove its recurrent neural networks, but preserve its additive attention mechanism.[1]
In 2018, in the ELMo paper, an entire sentence was processed before an embedding vector was assigning to each word in the sentence. A bi-directional LSTM was used to calculate such, deep contextualized embeddings for each word, improving upon the line of research from bag of words and word2vec.
In 2018, an encoder-only transformer was used in the (more than 1B-sized) BERT model, improving upon ELMo.[27]
In 2020, vision transformer[28] and speech-processing convolution-augmented transformer[29] outperformed recurrent neural networks, previously used for vision and speech.
In 2020, difficulties with converging the original transformer were solved by normalizing layers before (instead of after) multiheaded attention by Xiong et al. This is called pre-LN Transformer.[30]
In 2023, uni-directional ("autoregressive") transformers were being used in the (more than 100B-sized) GPT-3 and other OpenAI GPT models.[31][32]
Predecessors
Before transformers, predecessors of attention mechanism were added to gated recurrent neural networks, such as LSTMs and gated recurrent units (GRUs), which processed datasets sequentially. Dependency on previous token computations prevented them from being able to parallelize the attention mechanism. In 1992, fast weight controller was proposed as an alternative to recurrent neural networks that can learn "internal spotlights of attention".[16][4] In theory, the information from one token can propagate arbitrarily far down the sequence, but in practice the vanishing-gradient problem leaves the model's state at the end of a long sentence without precise, extractable information about preceding tokens.

The performance of old models was enhanced by adding an attention mechanism, which allowed a model to access any preceding point along the sequence. The attention layer weighs all previous states according to a learned measure of relevance, providing relevant information about far-away tokens. This proved to be especially useful in language translation, where far-away context can be essential for the meaning of a word in a sentence. The state vector has been accessible only after the last English word was processed while, for example, translating it from French by a LSTM model. Although in theory such a vector retains the information about the whole original sentence, in practice the information is poorly preserved. If an attention mechanism is added, the decoder is given access to the state vectors of every input word, not just the last, and can learn attention weights that dictate how much to attend to each input state vector. The augmentation of seq2seq models with the attention mechanism was first implemented in the context of machine translation by Bahdanau, Cho, and Bengio in 2014.[2][3]

Decomposable attention
In 2016, highly parallelizable decomposable attention was successfully combined with a feedforward network.[33] This indicated that attention mechanisms were powerful in themselves and that sequential recurrent processing of data was not necessary to achieve the quality gains of recurrent neural networks with attention. In 2017, Vaswani et al. also proposed replacing recurrent neural networks with self-attention and started the effort to evaluate that idea.[1] Transformers, using an attention mechanism, processing all tokens simultaneously, calculated "soft" weights between them in successive layers. Since the attention mechanism only uses information about other tokens from lower layers, it can be computed for all tokens in parallel, which leads to improved training speed.

Training
Methods for stabilizing training
The plain transformer architecture had difficulty converging. In the original paper[1] the authors recommended using learning rate warmup. That is, the learning rate should linearly scale up from 0 to maximal value for the first part of the training (usually recommended to be 2% of the total number of training steps), before decaying again.

A 2020 paper found that using layer normalization before (instead of after) multiheaded attention and feedforward layers stabilizes training, not requiring learning rate warmup.[30]

The GT3 model integrates CWTE, SWTE, and TTE using a self-adaptive gate layer, enabling efficient and effective fusion of three types of features for end-to-end text-driven stock market prediction.[34]

Pretrain-finetune
Transformers typically undergo self-supervised learning involving unsupervised pretraining followed by supervised fine-tuning. Pretraining is typically done on a larger dataset than fine-tuning, due to the limited availability of labeled training data. Tasks for pretraining and fine-tuning commonly include:

language modeling[12]
next-sentence prediction[12]
question answering[8]
reading comprehension
sentiment analysis[1]
paraphrasing[1]
The T5 transformer paper[35] documents a large number of pretraining tasks. Some examples are:

restoring corrupted text: Thank you <X> me to your party <Y> week. -> <X> for inviting <Y> last <Z> where the <Z> means "end of output".
translation: translate English to German: That is good. -> Das ist gut..
judging the grammatical acceptability of a sentence (CoLA sentence): The course is jumping well. -> not acceptable .
Applications
The transformer has had great success in natural language processing (NLP), for example the tasks of machine translation and time series prediction. Many large language models such as GPT-2, GPT-3, GPT-4, Claude, BERT, XLNet, RoBERTa and ChatGPT demonstrate the ability of transformers to perform a wide variety of such NLP-related tasks, and have the potential to find real-world applications. These may include:

machine translation
document summarization
document generation
named entity recognition (NER)[36]
biological sequence analysis
writing computer code based on requirements expressed in natural language.
video understanding.
In addition to the NLP applications, it has also been successful in other fields, such as computer vision, or the protein folding applications (such as AlphaFold).

As an illustrative example, Ithaca is an encoder-only transformer with three output heads. It takes as input ancient Greek inscription as sequences of characters, but with illegible characters replaced with "-". Its three output heads respectively outputs probability distributions over Greek characters, location of inscription, and date of inscription.[37]

Implementations
The transformer model has been implemented in standard deep learning frameworks such as TensorFlow and PyTorch.

Transformers is a library produced by Hugging Face that supplies transformer-based architectures and pretrained models.[11]

Architecture

An illustration of main components of the transformer model from the original paper, where layer normalization was performed after multiheaded attention. In a 2020 paper it was found that placing the layer normalization in front of the multiheaded attention (instead of after) improves the training stability[30].
All transformers have the same primary components:

Tokenizers, which convert text into tokens.
A single embedding layer, which converts tokens and positions of the tokens into vector representations.
Transformer layers, which carry out repeated transformations on the vector representations, extracting more and more linguistic information. These consist of alternating attention and feedforward layers.
(optional) Un-embedding layer, which converts the final vector representations back to a probability distribution over the tokens.
Transformer layers can be one of two types, encoder and decoder. In the original paper both of them were used, while later models included only one type of them. BERT is an example of an encoder-only model; GPT are decoder-only models.

Input
The input text is parsed into tokens by a tokenizer, most often a byte pair encoding tokenizer, and each token is converted into a vector via looking up from a word embedding table. Then, positional information of the token is added to the word embedding.

Encoder-decoder architecture
Like earlier seq2seq models, the original transformer model used an encoder-decoder architecture. The encoder consists of encoding layers that process the input tokens iteratively one layer after another, while the decoder consists of decoding layers that iteratively process the encoder's output as well as the decoder output's tokens so far.

The function of each encoder layer is to generate contextualized token representations, where each representation corresponds to a token that "mixes" information from other input tokens via self-attention mechanism. Each decoder layer contains two attention sublayers: (1) cross-attention for incorporating the output of encoder (contextualized input token representations), and (2) self-attention for "mixing" information among the input tokens to the decoder (i.e., the tokens generated so far during inference time).[38][39]

Both the encoder and decoder layers have a feed-forward neural network for additional processing of the outputs and contain residual connections and layer normalization steps.[39]

Scaled dot-product attention
The transformer building blocks are scaled dot-product attention units. For each attention unit, the transformer model learns three weight matrices: the query weights
ğ‘Š
ğ‘„
{\displaystyle W_{Q}}, the key weights
ğ‘Š
ğ¾
{\displaystyle W_{K}}, and the value weights
ğ‘Š
ğ‘‰
{\displaystyle W_{V}}. For each token
ğ‘–
{\displaystyle i}, the input token representation
ğ‘¥
ğ‘–
{\displaystyle x_{i}} is multiplied with each of the three weight matrices to produce a query vector
ğ‘
ğ‘–
=
ğ‘¥
ğ‘–
ğ‘Š
ğ‘„
{\displaystyle q_{i}=x_{i}W_{Q}}, a key vector
ğ‘˜
ğ‘–
=
ğ‘¥
ğ‘–
ğ‘Š
ğ¾
{\displaystyle k_{i}=x_{i}W_{K}}, and a value vector
ğ‘£
ğ‘–
=
ğ‘¥
ğ‘–
ğ‘Š
ğ‘‰
{\displaystyle v_{i}=x_{i}W_{V}}. Attention weights are calculated using the query and key vectors: the attention weight
ğ‘
ğ‘–
ğ‘—
{\displaystyle a_{ij}} from token
ğ‘–
{\displaystyle i} to token
ğ‘—
{\displaystyle j} is the dot product between
ğ‘
ğ‘–
{\displaystyle q_{i}} and
ğ‘˜
ğ‘—
{\displaystyle k_{j}}. The attention weights are divided by the square root of the dimension of the key vectors,
ğ‘‘
ğ‘˜
{\displaystyle {\sqrt {d_{k}}}}, which stabilizes gradients during training, and passed through a softmax which normalizes the weights. The fact that
ğ‘Š
ğ‘„
{\displaystyle W_{Q}} and
ğ‘Š
ğ¾
{\displaystyle W_{K}} are different matrices allows attention to be non-symmetric: if token
ğ‘–
{\displaystyle i} attends to token
ğ‘—
{\displaystyle j} (i.e.
ğ‘
ğ‘–
â‹…
ğ‘˜
ğ‘—
{\displaystyle q_{i}\cdot k_{j}} is large), this does not necessarily mean that token
ğ‘—
{\displaystyle j} will attend to token
ğ‘–
{\displaystyle i} (i.e.
ğ‘
ğ‘—
â‹…
ğ‘˜
ğ‘–
{\displaystyle q_{j}\cdot k_{i}} could be small). The output of the attention unit for token
ğ‘–
{\displaystyle i} is the weighted sum of the value vectors of all tokens, weighted by
ğ‘
ğ‘–
ğ‘—
{\displaystyle a_{ij}}, the attention from token
ğ‘–
{\displaystyle i} to each token.

The attention calculation for all tokens can be expressed as one large matrix calculation using the softmax function, which is useful for training due to computational matrix operation optimizations that quickly compute matrix operations. The matrices
ğ‘„
{\displaystyle Q},
ğ¾
{\displaystyle K} and
ğ‘‰
{\displaystyle V} are defined as the matrices where the
ğ‘–
{\displaystyle i}th rows are vectors
ğ‘
ğ‘–
{\displaystyle q_{i}},
ğ‘˜
ğ‘–
{\displaystyle k_{i}}, and
ğ‘£
ğ‘–
{\displaystyle v_{i}} respectively. Then we can represent the attention as

Attention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘„
ğ¾
T
ğ‘‘
ğ‘˜
)
ğ‘‰
{\displaystyle {\begin{aligned}{\text{Attention}}(Q,K,V)={\text{softmax}}\left({\frac {QK^{\mathrm {T} }}{\sqrt {d_{k}}}}\right)V\end{aligned}}}
where softmax is taken over the horizontal axis.

Multi-head attention
One set of
(
ğ‘Š
ğ‘„
,
ğ‘Š
ğ¾
,
ğ‘Š
ğ‘‰
)
{\displaystyle \left(W_{Q},W_{K},W_{V}\right)} matrices is called an attention head, and each layer in a transformer model has multiple attention heads. While each attention head attends to the tokens that are relevant to each token, multiple attention heads allow the model to do this for different definitions of "relevance". In addition, the influence field representing relevance can become progressively dilated in successive layers. Many transformer attention heads encode relevance relations that are meaningful to humans. For example, some attention heads can attend mostly to the next word, while others mainly attend from verbs to their direct objects.[40] The computations for each attention head can be performed in parallel, which allows for fast processing. The outputs for the attention layer are concatenated to pass into the feed-forward neural network layers.

Concretely, let the multiple attention heads be indexed by
ğ‘–
{\displaystyle i}, then we have

MultiheadedAttention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
Concat
ğ‘–
âˆˆ
[
#
â„
ğ‘’
ğ‘
ğ‘‘
ğ‘ 
]
(
Attention
(
ğ‘‹
ğ‘Š
ğ‘–
ğ‘„
,
ğ‘‹
ğ‘Š
ğ‘–
ğ¾
,
ğ‘‹
ğ‘Š
ğ‘–
ğ‘‰
)
)
ğ‘Š
ğ‘‚
{\displaystyle {\text{MultiheadedAttention}}(Q,K,V)={\text{Concat}}_{i\in [\#heads]}({\text{Attention}}(XW_{i}^{Q},XW_{i}^{K},XW_{i}^{V}))W^{O}}
where the matrix
ğ‘‹
{\displaystyle X} is the concatenation of word embeddings, and the matrices
ğ‘Š
ğ‘–
ğ‘„
,
ğ‘Š
ğ‘–
ğ¾
,
ğ‘Š
ğ‘–
ğ‘‰
{\displaystyle W_{i}^{Q},W_{i}^{K},W_{i}^{V}} are "projection matrices" owned by individual attention head
ğ‘–
{\displaystyle i}, and
ğ‘Š
ğ‘‚
{\displaystyle W^{O}} is a final projection matrix owned by the whole multi-headed attention head.
Masked attention
It may be necessary to cut out attention links between some word-pairs. For example, the decoder for token position
ğ‘¡
{\displaystyle t} should not have access to token position
ğ‘¡
+
1
{\displaystyle t+1}. This may be accomplished before the softmax stage by adding a mask matrix
ğ‘€
{\displaystyle M} that is
âˆ’
âˆ{\displaystyle -\infty } at entries where the attention link must be cut, and
0
{\displaystyle 0} at other places:

MaskedAttention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘€
+
ğ‘„
ğ¾
T
ğ‘‘
ğ‘˜
)
ğ‘‰
{\displaystyle {\begin{aligned}{\text{MaskedAttention}}(Q,K,V)={\text{softmax}}\left(M+{\frac {QK^{\mathrm {T} }}{\sqrt {d_{k}}}}\right)V\end{aligned}}}
For example, the following mask matrix is used in autoregressive modeling:
ğ‘€
=
[
0
âˆ’
âˆ
âˆ’
âˆ
â€¦
âˆ’
âˆ
0
0
âˆ’
âˆ
â€¦
âˆ’
âˆ
0
0
0
â€¦
âˆ’
âˆ
â‹®
â‹®
â‹®
â‹±
â‹®
0
0
0
â€¦
0
]
{\displaystyle M={\begin{bmatrix}0&-\infty &-\infty &\dots &-\infty \\0&0&-\infty &\dots &-\infty \\0&0&0&\dots &-\infty \\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\dots &0\end{bmatrix}}}
In words, it means that each token can pay attention to itself, and every token before it, but not any after it.
Encoder
Each encoder consists of two major components: a self-attention mechanism and a feed-forward neural network. The self-attention mechanism accepts input encodings from the previous encoder and weights their relevance to each other to generate output encodings. The feed-forward neural network further processes each output encoding individually. These output encodings are then passed to the next encoder as its input, as well as to the decoders.

The first encoder takes positional information and embeddings of the input sequence as its input, rather than encodings. The positional information is necessary for the transformer to make use of the order of the sequence, because no other part of the transformer makes use of this.[1]

The encoder is bidirectional. Attention can be placed on tokens before and after the current token. Tokens are used instead of words to account for polysemy.


A diagram of a sinusoidal positional encoding with parameters
ğ‘
=
10000
,
ğ‘‘
=
100
{\displaystyle N=10000,d=100}
Positional encoding
A positional encoding is a fixed-size vector representation that encapsulates the relative positions of tokens within a target sequence: it provides the transformer model with information about where the words are in the input sequence.

The positional encoding is defined as a function of type
ğ‘“
:
ğ‘…
â†’
ğ‘…
ğ‘‘
;
ğ‘‘
âˆˆ
ğ‘
,
ğ‘‘
>
0
{\displaystyle f:\mathbb {R} \to \mathbb {R} ^{d};d\in \mathbb {Z} ,d>0}, where
ğ‘‘
{\displaystyle d} is a positive even integer. The full positional encoding â€“ as defined in the original paper â€“ is given by the equation:

(
ğ‘“
(
ğ‘¡
)
2
ğ‘˜
,
ğ‘“
(
ğ‘¡
)
2
ğ‘˜
+
1
)
=
(
sin
â¡
(
ğœƒ
)
,
cos
â¡
(
ğœƒ
)
)
âˆ€
ğ‘˜
âˆˆ
{
0
,
1
,
â€¦
,
ğ‘‘
/
2
âˆ’
1
}
{\displaystyle (f(t)_{2k},f(t)_{2k+1})=(\sin(\theta ),\cos(\theta ))\quad \forall k\in \{0,1,\ldots ,d/2-1\}}
where
ğœƒ
=
ğ‘¡
ğ‘Ÿ
ğ‘˜
,
ğ‘Ÿ
=
ğ‘
2
/
ğ‘‘
{\displaystyle \theta ={\frac {t}{r^{k}}},r=N^{2/d}}.
Here,
ğ‘
{\displaystyle N} is a free parameter that should be significantly larger than the biggest
ğ‘˜
{\displaystyle k} that would be input into the positional encoding function. In the original paper,[1] the authors chose
ğ‘
=
10000
{\displaystyle N=10000}.

The function is in a simpler form when written as a complex function of type
ğ‘“
:
ğ‘…
â†’
ğ¶
ğ‘‘
/
2
{\displaystyle f:\mathbb {R} \to \mathbb {C} ^{d/2}}

ğ‘“
(
ğ‘¡
)
=
(
ğ‘’
ğ‘–
ğ‘¡
/
ğ‘Ÿ
ğ‘˜
)
ğ‘˜
=
0
,
1
,
â€¦
,
ğ‘‘
2
âˆ’
1
{\displaystyle f(t)=\left(e^{it/r^{k}}\right)_{k=0,1,\ldots ,{\frac {d}{2}}-1}}
where
ğ‘Ÿ
=
ğ‘
2
/
ğ‘‘
{\displaystyle r=N^{2/d}}.
The main reason the authors chose this as the positional encoding function is that it allows one to perform shifts as linear transformations:

ğ‘“
(
ğ‘¡
+
Î”
ğ‘¡
)
=
d
i
a
g
(
ğ‘“
(
Î”
ğ‘¡
)
)
ğ‘“
(
ğ‘¡
)
{\displaystyle f(t+\Delta t)=\mathrm {diag} (f(\Delta t))f(t)}
where
Î”
ğ‘¡
âˆˆ
ğ‘…
{\displaystyle \Delta t\in \mathbb {R} } is the distance one wishes to shift. This allows the transformer to take any encoded position, and find the encoding of the position n-steps-ahead or n-steps-behind, by a matrix multiplication.
By taking a linear sum, any convolution can also be implemented as linear transformations:

âˆ‘
ğ‘—
ğ‘
ğ‘—
ğ‘“
(
ğ‘¡
+
Î”
ğ‘¡
ğ‘—
)
=
(
âˆ‘
ğ‘—
ğ‘
ğ‘—
d
i
a
g
(
ğ‘“
(
Î”
ğ‘¡
ğ‘—
)
)
)
ğ‘“
(
ğ‘¡
)
{\displaystyle \sum _{j}c_{j}f(t+\Delta t_{j})=\left(\sum _{j}c_{j}\,\mathrm {diag} (f(\Delta t_{j}))\right)f(t)}
for any constants
ğ‘
ğ‘—
{\displaystyle c_{j}}. This allows the transformer to take any encoded position and find a linear sum of the encoded locations of its neighbors. This sum of encoded positions, when fed into the attention mechanism, would create attention weights on its neighbors, much like what happens in a convolutional neural network language model. In the author's words, "we hypothesized it would allow the model to easily learn to attend by relative position."
In typical implementations, all operations are done over the real numbers, not the complex numbers, but since complex multiplication can be implemented as real 2-by-2 matrix multiplication, this is a mere notational difference.

Decoder
Each decoder consists of three major components: a self-attention mechanism, an attention mechanism over the encodings, and a feed-forward neural network. The decoder functions in a similar fashion to the encoder, but an additional attention mechanism is inserted which instead draws relevant information from the encodings generated by the encoders. This mechanism can also be called the encoder-decoder attention.[1][39]

Like the first encoder, the first decoder takes positional information and embeddings of the output sequence as its input, rather than encodings. The transformer must not use the current or future output to predict an output, so the output sequence must be partially masked to prevent this reverse information flow.[1] This allows for autoregressive text generation. For all attention heads, attention can't be placed on following tokens. The last decoder is followed by a final linear transformation and softmax layer, to produce the output probabilities over the vocabulary.

All members of OpenAI's GPT series have a decoder-only architecture.

Terminology
In large language models, the terminology is somewhat different than the terminology used in the original Transformer paper:[41]

"encoder only": full encoder, full decoder.
"encoder-decoder": full encoder, autoregressive decoder.
"decoder only": autoregressive encoder, autoregressive decoder.
Here "autoregressive" means that a mask is inserted in the attention head to zero out all attention from one token to all tokens following it, as described in the "masked attention" section.

Generally, Transformer-based language models are of two types: causal (or "autoregressive") and masked. The GPT series is causal and decoder only. BERT is masked and encoder only.[42][43] The T5 series is encoder-decoder, with a full encoder and autoregressive decoder.[35]

Subsequent work
Alternative activation functions
The original transformer uses ReLU activation function. Other activation functions were developed, such as SwiGLU.[44]

Alternative positional encodings
Transformers may use other positional encoding methods than sinusoidal.[45]

RoPE
RoPE (rotary positional embedding),[46] is best explained by considering a list of 2-dimensional vectors
[
(
ğ‘¥
1
(
1
)
,
ğ‘¥
1
(
2
)
)
,
(
ğ‘¥
2
(
1
)
,
ğ‘¥
2
(
2
)
)
,
(
ğ‘¥
3
(
1
)
,
ğ‘¥
3
(
2
)
)
,
.
.
.
]
{\displaystyle [(x_{1}^{(1)},x_{1}^{(2)}),(x_{2}^{(1)},x_{2}^{(2)}),(x_{3}^{(1)},x_{3}^{(2)}),...]}. Now pick some angle
ğœƒ{\displaystyle \theta }. Then RoPE encoding is

RoPE
(
ğ‘¥
ğ‘š
(
1
)
,
ğ‘¥
ğ‘š
(
2
)
,
ğ‘š
)
=
(
cos
â¡
ğ‘š
ğœƒ
âˆ’
sin
â¡
ğ‘š
ğœƒ
sin
â¡
ğ‘š
ğœƒ
cos
â¡
ğ‘š
ğœƒ
)
(
ğ‘¥
ğ‘š
(
1
)
ğ‘¥
ğ‘š
(
2
)
)
=
(
ğ‘¥
ğ‘š
(
1
)
cos
â¡
ğ‘š
ğœƒ
âˆ’
ğ‘¥
ğ‘š
(
2
)
sin
â¡
ğ‘š
ğœƒ
ğ‘¥
ğ‘š
(
2
)
cos
â¡
ğ‘š
ğœƒ
+
ğ‘¥
ğ‘š
(
1
)
sin
â¡
ğ‘š
ğœƒ
)
{\displaystyle {\text{RoPE}}{\big (}x_{m}^{(1)},x_{m}^{(2)},m{\big )}={\begin{pmatrix}\cos m\theta &-\sin m\theta \\\sin m\theta &\cos m\theta \end{pmatrix}}{\begin{pmatrix}x_{m}^{(1)}\\x_{m}^{(2)}\\\end{pmatrix}}={\begin{pmatrix}x_{m}^{(1)}\cos m\theta -x_{m}^{(2)}\sin m\theta \\x_{m}^{(2)}\cos m\theta +x_{m}^{(1)}\sin m\theta \\\end{pmatrix}}}
Equivalently, if we write the 2-dimensional vectors as complex numbers
ğ‘§
ğ‘š
:=
ğ‘¥
ğ‘š
(
1
)
+
ğ‘–
ğ‘¥
ğ‘š
(
2
)
{\displaystyle z_{m}:=x_{m}^{(1)}+ix_{m}^{(2)}}, then RoPE encoding is just multiplication by an angle:
RoPE
(
ğ‘§
ğ‘š
,
ğ‘š
)
=
ğ‘’
ğ‘–
ğ‘š
ğœƒ
ğ‘§
ğ‘š
{\displaystyle {\text{RoPE}}{\big (}z_{m},m{\big )}=e^{im\theta }z_{m}}
For a list of
2
ğ‘›
{\displaystyle 2n}-dimensional vectors, a RoPE encoder is defined by a sequence of angles
ğœƒ
(
1
)
,
.
.
.
,
ğœƒ
(
ğ‘›
)
{\displaystyle \theta ^{(1)},...,\theta ^{(n)}}. Then the RoPE encoding is applied to each pair of coordinates.
The benefit of RoPE is that the dot-product between two vectors depends on their relative location only:

RoPE
(
ğ‘¥
,
ğ‘š
)
ğ‘‡
RoPE
(
ğ‘¦
,
ğ‘›
)
=
RoPE
(
ğ‘¥
,
ğ‘š
+
ğ‘˜
)
ğ‘‡
RoPE
(
ğ‘¦
,
ğ‘›
+
ğ‘˜
)
{\displaystyle {\text{RoPE}}{\big (}x,m{\big )}^{T}{\text{RoPE}}{\big (}y,n{\big )}={\text{RoPE}}{\big (}x,m+k{\big )}^{T}{\text{RoPE}}{\big (}y,n+k{\big )}}
for any integer
ğ‘˜
{\displaystyle k}.
ALiBi
ALiBi (Attention with Linear Biases)[47] is not a replacement for the positional encoder on the original transformer. Instead, it is an additional positional encoder that is directly plugged into the attention mechanism. Specifically, the ALiBi attention mechanism is

Attention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘„
ğ¾
T
ğ‘‘
ğ‘˜
+
ğ‘ 
ğµ
)
ğ‘‰
{\displaystyle {\begin{aligned}{\text{Attention}}(Q,K,V)={\text{softmax}}\left({\frac {QK^{\mathrm {T} }}{\sqrt {d_{k}}}}+sB\right)V\end{aligned}}}
Here,
ğ‘ 
{\displaystyle s} is a real number ("scalar"), and
ğµ
{\displaystyle B} is the linear bias matrix defined by
ğµ
=
(
0
1
2
3
â‹¯
âˆ’
1
0
1
2
â‹¯
âˆ’
2
âˆ’
1
0
1
â‹¯
âˆ’
3
âˆ’
2
âˆ’
1
0
â‹¯
â‹®
â‹®
â‹®
â‹®
â‹±
)
{\displaystyle B={\begin{pmatrix}0&1&2&3&\cdots \\-1&0&1&2&\cdots \\-2&-1&0&1&\cdots \\-3&-2&-1&0&\cdots \\\vdots &\vdots &\vdots &\vdots &\ddots \\\end{pmatrix}}}
in other words,
ğµ
ğ‘–
,
ğ‘—
=
ğ‘—
âˆ’
ğ‘–
{\displaystyle B_{i,j}=j-i}.
ALiBi allows pretraining on short context windows, then finetuning on longer context windows. Since it is directly plugged into the attention mechanism, it can be combined with any positional encoder that is plugged into the "bottom" of the entire network (which is where the sinusoidal encoder on the original transformer, as well as RoPE and many others, are located).

Relative Position Encodings
Relative Position Encodings[48] is similar to ALiBi, but more generic:

Attention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘„
ğ¾
T
ğ‘‘
ğ‘˜
+
ğµ
)
ğ‘‰
{\displaystyle {\begin{aligned}{\text{Attention}}(Q,K,V)={\text{softmax}}\left({\frac {QK^{\mathrm {T} }}{\sqrt {d_{k}}}}+B\right)V\end{aligned}}}
where
ğµ
{\displaystyle B} is a Toeplitz matrix, that is,
ğµ
ğ‘–
,
ğ‘—
=
ğµ
ğ‘–
â€²
,
ğ‘—
â€²
{\displaystyle B_{i,j}=B_{i',j'}} whenever
ğ‘–
âˆ’
ğ‘—
=
ğ‘–
â€²
âˆ’
ğ‘—
â€²
{\displaystyle i-j=i'-j'}.
Efficient implementation
FlashAttention
FlashAttention[49] is an algorithm that implements the transformer attention mechanism efficiently on a GPU. It performs matrix multiplications in blocks, such that each block fits within the cache of a GPU, and by careful management of the blocks it minimizes data copying between GPU caches (as data movement is slow).

An improved version, FlashAttention-2,[50][51][52] was developed to cater to the rising demand for language models capable of handling longer context lengths. It offers enhancements in work partitioning and parallelism, enabling it to achieve up to 230 TFLOPs/s on A100 GPUs (FP16/BF16), a 2x speed increase over the original FlashAttention.

Key advancements in FlashAttention-2 include the reduction of non-matmul FLOPs, improved parallelism over the sequence length dimension, better work partitioning between GPU warps, and added support for head dimensions up to 256 and multi-query attention (MQA) and grouped-query attention (GQA).

Benchmarks revealed FlashAttention-2 to be up to 2x faster than FlashAttention and up to 9x faster than a standard attention implementation in PyTorch. Future developments include optimization for new hardware like H100 GPUs and new data types like FP8.

Multi-Query Attention
Multi-Query Attention changes the multiheaded attention mechanism.[53] Whereas normally,

MultiheadedAttention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
Concat
ğ‘–
âˆˆ
[
#
â„
ğ‘’
ğ‘
ğ‘‘
ğ‘ 
]
(
Attention
(
ğ‘‹
ğ‘Š
ğ‘–
ğ‘„
,
ğ‘‹
ğ‘Š
ğ‘–
ğ¾
,
ğ‘‹
ğ‘Š
ğ‘–
ğ‘‰
)
)
ğ‘Š
ğ‘‚
{\displaystyle {\text{MultiheadedAttention}}(Q,K,V)={\text{Concat}}_{i\in [\#heads]}({\text{Attention}}(XW_{i}^{Q},XW_{i}^{K},XW_{i}^{V}))W^{O}}
with Multi-Query Attention, there is just one
ğ‘Š
ğ¾
,
ğ‘Š
ğ‘‰
{\displaystyle W^{K},W^{V}}, thus:
MultiQueryAttention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
Concat
ğ‘–
âˆˆ
[
#
â„
ğ‘’
ğ‘
ğ‘‘
ğ‘ 
]
(
Attention
(
ğ‘‹
ğ‘Š
ğ‘–
ğ‘„
,
ğ‘‹
ğ‘Š
ğ¾
,
ğ‘‹
ğ‘Š
ğ‘‰
)
)
ğ‘Š
ğ‘‚
{\displaystyle {\text{MultiQueryAttention}}(Q,K,V)={\text{Concat}}_{i\in [\#heads]}({\text{Attention}}(XW_{i}^{Q},XW^{K},XW^{V}))W^{O}}
This has a neutral effect on model quality and training speed, but increases inference speed.

Speculative decoding
Transformers are used in large language models for autoregressive sequence generation: generating a stream of text, one token at a time. However, in most settings, decoding from a language models is memory-bound, meaning that we have spare compute power available. Speculative decoding[54][55] uses this spare compute power by computing several tokens in parallel. Similarly to speculative execution in CPUs, future tokens are computed concurrently, by speculating on the value of previous tokens, and are later discarded if it turns out the speculation was incorrect.

Specifically, consider a transformer model like GPT-3 with a context window size of 512. To generate an entire context window autoregressively with greedy decoding, it must be run for 512 times, each time generating a token
ğ‘¥
1
,
ğ‘¥
2
,
.
.
.
,
ğ‘¥
512
{\displaystyle x_{1},x_{2},...,x_{512}}. However, if we had some educated guess for the values of these tokens, we could verify all of them in parallel, in one run of the model, by checking that each
ğ‘¥
ğ‘¡
{\displaystyle x_{t}} is indeed the token with the largest log-likelihood in the
ğ‘¡
{\displaystyle t}-th output.

In speculative decoding, a smaller model or some other simple heuristic is used to generate a few speculative tokens that are subsequently verified by the larger model. For example, suppose a small model generated four speculative tokens:
ğ‘¥
1
~
,
ğ‘¥
2
~
,
ğ‘¥
3
~
,
ğ‘¥
4
~{\displaystyle {\tilde {x_{1}}},{\tilde {x_{2}}},{\tilde {x_{3}}},{\tilde {x_{4}}}}. These tokens are run through the larger model, and only
ğ‘¥
1
~{\displaystyle {\tilde {x_{1}}}} and
ğ‘¥
2
~{\displaystyle {\tilde {x_{2}}}} are accepted. The same run of the large model already generated a new token
ğ‘¥
3
{\displaystyle x_{3}} to replace
ğ‘¥
3
~{\displaystyle {\tilde {x_{3}}}}, and
ğ‘¥
4
~{\displaystyle {\tilde {x_{4}}}} is completely discarded. The process then repeats (starting from the 4th token) until all tokens are generated.

For non-greedy decoding, similar ideas apply, except the speculative tokens are accepted or rejected stochastically, in a way that guarantees the final output distribution is the same as if speculative decoding was not used.[54][56]

Sub-quadratic transformers
Training transformer-based architectures can be expensive, especially for long inputs.[57] Alternative architectures include the Reformer (which reduces the computational load from
ğ‘‚
(
ğ‘
2
)
{\displaystyle O(N^{2})} to
ğ‘‚
(
ğ‘
ln
â¡
ğ‘
)
{\displaystyle O(N\ln N)}[57]), or models like ETC/BigBird (which can reduce it to
ğ‘‚
(
ğ‘
)
{\displaystyle O(N)})[58] where
ğ‘
{\displaystyle N} is the length of the sequence. This is done using locality-sensitive hashing and reversible layers.[59][60]

Ordinary transformers require a memory size that is quadratic in the size of the context window. Attention-free transformers[61] reduce this to a linear dependence while still retaining the advantages of a transformer by linking the key to the value.

Long Range Arena (2020)[62] is a standard benchmark for comparing the behavior of transformer architectures over long inputs.

Random Feature Attention (2021)[63] uses Fourier random features:

ğœ‘
(
ğ‘¥
)
=
1
ğ·
[
cos
â¡
âŸ¨
ğ‘¤
1
,
ğ‘¥
âŸ©
,
sin
â¡
âŸ¨
ğ‘¤
1
,
ğ‘¥
âŸ©
,
â‹¯
cos
â¡
âŸ¨
ğ‘¤
ğ·
,
ğ‘¥
âŸ©
,
sin
â¡
âŸ¨
ğ‘¤
ğ·
,
ğ‘¥
âŸ©
]
ğ‘‡
{\displaystyle \varphi (x)={\frac {1}{\sqrt {D}}}[\cos \langle w_{1},x\rangle ,\sin \langle w_{1},x\rangle ,\cdots \cos \langle w_{D},x\rangle ,\sin \langle w_{D},x\rangle ]^{T}}
where
ğ‘¤
1
,
.
.
.
,
ğ‘¤
ğ·
{\displaystyle w_{1},...,w_{D}} are independent samples from the normal distribution
ğ‘
(
0
,
ğœ
2
ğ¼
)
{\displaystyle N(0,\sigma ^{2}I)}. This choice of parameters satisfy
ğ¸
[
âŸ¨
ğœ‘
(
ğ‘¥
)
,
ğœ‘
(
ğ‘¦
)
âŸ©
]
=
ğ‘’
â€–
ğ‘¥
âˆ’
ğ‘¦
â€–
2
2
ğœ
2
{\displaystyle \mathbb {E} [\langle \varphi (x),\varphi (y)\rangle ]=e^{\frac {\|x-y\|^{2}}{2\sigma ^{2}}}}, or
ğ‘’
âŸ¨
ğ‘¥
,
ğ‘¦
âŸ©
/
ğœ
2
=
ğ¸
[
âŸ¨
ğ‘’
â€–
ğ‘¥
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘¥
)
,
ğ‘’
â€–
ğ‘¦
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘¦
)
âŸ©
]
â‰ˆ
âŸ¨
ğ‘’
â€–
ğ‘¥
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘¥
)
,
ğ‘’
â€–
ğ‘¦
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘¦
)
âŸ©{\displaystyle e^{\langle x,y\rangle /\sigma ^{2}}=\mathbb {E} [\langle e^{\|x\|^{2}/2\sigma ^{2}}\varphi (x),e^{\|y\|^{2}/2\sigma ^{2}}\varphi (y)\rangle ]\approx \langle e^{\|x\|^{2}/2\sigma ^{2}}\varphi (x),e^{\|y\|^{2}/2\sigma ^{2}}\varphi (y)\rangle }
Consequently, the one-headed attention, with one query, can be written as
Attention
(
ğ‘
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘
ğ¾
T
ğ‘‘
ğ‘˜
)
ğ‘‰
â‰ˆ
ğœ‘
(
ğ‘
)
ğ‘‡
âˆ‘
ğ‘–
ğ‘’
â€–
ğ‘˜
ğ‘–
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘˜
ğ‘–
)
ğ‘£
ğ‘–
ğ‘‡
ğœ‘
(
ğ‘
)
ğ‘‡
âˆ‘
ğ‘–
ğ‘’
â€–
ğ‘˜
ğ‘–
â€–
2
/
2
ğœ
2
ğœ‘
(
ğ‘˜
ğ‘–
)
{\displaystyle {\text{Attention}}(q,K,V)={\text{softmax}}\left({\frac {qK^{\mathrm {T} }}{\sqrt {d_{k}}}}\right)V\approx {\frac {\varphi (q)^{T}\sum _{i}e^{\|k_{i}\|^{2}/2\sigma ^{2}}\varphi (k_{i})v_{i}^{T}}{\varphi (q)^{T}\sum _{i}e^{\|k_{i}\|^{2}/2\sigma ^{2}}\varphi (k_{i})}}}
where
ğœ
=
ğ‘‘
ğ¾
1
/
4
{\displaystyle \sigma =d_{K}^{1/4}}. Similarly for multiple queries, and for multiheaded attention.
This approximation can be computed in linear time, as we can compute the matrix
ğœ‘
(
ğ‘˜
ğ‘–
)
ğ‘£
ğ‘–
ğ‘‡
{\displaystyle \varphi (k_{i})v_{i}^{T}} first, then multiply it with the query. In essence, we have managed to obtain a more precise version of

Attention
(
ğ‘„
,
ğ¾
,
ğ‘‰
)
=
softmax
(
ğ‘„
ğ¾
T
ğ‘‘
ğ‘˜
)
ğ‘‰
â‰ˆ
ğ‘„
(
ğ¾
ğ‘‡
ğ‘‰
/
ğ‘‘
ğ‘˜
)
{\displaystyle {\text{Attention}}(Q,K,V)={\text{softmax}}\left({\frac {QK^{\mathrm {T} }}{\sqrt {d_{k}}}}\right)V\approx Q(K^{T}V/{\sqrt {d_{k}}})}
Performer (2022)[64] uses the same Random Feature Attention, but
ğ‘¤
1
,
.
.
.
,
ğ‘¤
ğ·
{\displaystyle w_{1},...,w_{D}} are first independently sampled from the normal distribution
ğ‘
(
0
,
ğœ
2
ğ¼
)
{\displaystyle N(0,\sigma ^{2}I)}, then they are Gram-Schmidt processed.

Multimodality
Transformers can also be used/adapted for modalities (input or output) beyond just text, usually by finding a way to "tokenize" the modality.

Vision transformers[28] adapt the transformer to computer vision by breaking down input images as a series of patches, turning them into vectors, and treating them like tokens in a standard transformer.

Conformer[29] and later Whisper[65] follow the same pattern for speech recognition, first turning the speech signal into a spectrogram, which is then treated like an image, i.e. broken down into a series of patches, turned into vectors and treated like tokens in a standard transformer.

Perceivers by Andrew Jaegle et al. (2021)[66][67] can learn from large amounts of heterogeneous data.

Regarding image outputs, Peebles et al introduced a diffusion transformer (DiT) which facilitates use of the transformer architecture for diffusion-based image production.[68] Also, Google released a transformer-centric image generator called "Muse" based on parallel decoding and masked generative transformer technology.[69] (Transformers played a less-central role with prior image-producing technologies,[70] albeit still a significant one.[71])

See also
Perceiver â€“ Machine learning algorithm for non-textual data
BERT (language model) â€“ Language model developed by Google
GPT-3 â€“ 2020 text-generating language model
GPT-4 â€“ 2023 text-generating language model
ChatGPT â€“ Chatbot developed by OpenAI
Wu Dao â€“ Chinese multimodal artificial intelligence program
Vision transformer â€“ Machine learning algorithm for vision processing
BLOOM (language model) â€“ Open-access multilingual language model
References
 Vaswani, Ashish; Shazeer, Noam; Parmar, Niki; Uszkoreit, Jakob; Jones, Llion; Gomez, Aidan N; Kaiser, Åukasz; Polosukhin, Illia (2017). "Attention is All you Need" (PDF). Advances in Neural Information Processing Systems. 30. Curran Associates, Inc.
 Bahdanau; Cho, Kyunghyun; Bengio, Yoshua (September 1, 2014). "Neural Machine Translation by Jointly Learning to Align and Translate". arXiv:1409.0473 [cs.CL].
 Luong, Minh-Thang; Pham, Hieu; Manning, Christopher D. (August 17, 2015). "Effective Approaches to Attention-based Neural Machine Translation". arXiv:1508.04025 [cs.CL].
 Schmidhuber, JÃ¼rgen (1992). "Learning to control fast-weight memories: an alternative to recurrent nets". Neural Computation. 4 (1): 131â€“139. doi:10.1162/neco.1992.4.1.131. S2CID 16683347.
 Schlag, Imanol; Irie, Kazuki; Schmidhuber, JÃ¼rgen (2021). "Linear Transformers Are Secretly Fast Weight Programmers". ICML 2021. Springer. pp. 9355â€“9366.
 Katharopoulos, Angelos; Vyas, Apoorv; Pappas, Nikolaos; Fleuret, FranÃ§ois (2020). "Transformers are RNNs: Fast autoregressive Transformers with linear attention". ICML 2020. PMLR. pp. 5156â€“5165.
 Hochreiter, Sepp; Schmidhuber, JÃ¼rgen (1 November 1997). "Long Short-Term Memory". Neural Computation. 9 (8): 1735â€“1780. doi:10.1162/neco.1997.9.8.1735. ISSN 0899-7667. PMID 9377276. S2CID 1915014.
 "Better Language Models and Their Implications". OpenAI. 2019-02-14. Archived from the original on 2020-12-19. Retrieved 2019-08-25.
 He, Cheng (31 December 2021). "Transformer in CV". Transformer in CV. Towards Data Science. Archived from the original on 16 April 2023. Retrieved 19 June 2021.
 Radford, Alec; Jong Wook Kim; Xu, Tao; Brockman, Greg; McLeavey, Christine; Sutskever, Ilya (2022). "Robust Speech Recognition via Large-Scale Weak Supervision". arXiv:2212.04356 [eess.AS].
 Wolf, Thomas; Debut, Lysandre; Sanh, Victor; Chaumond, Julien; Delangue, Clement; Moi, Anthony; Cistac, Pierric; Rault, Tim; Louf, Remi; Funtowicz, Morgan; Davison, Joe; Shleifer, Sam; von Platen, Patrick; Ma, Clara; Jernite, Yacine; Plu, Julien; Xu, Canwen; Le Scao, Teven; Gugger, Sylvain; Drame, Mariama; Lhoest, Quentin; Rush, Alexander (2020). "Transformers: State-of-the-Art Natural Language Processing". Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing: System Demonstrations. pp. 38â€“45. doi:10.18653/v1/2020.emnlp-demos.6. S2CID 208117506.
 "Open Sourcing BERT: State-of-the-Art Pre-training for Natural Language Processing". Google AI Blog. 2 November 2018. Archived from the original on 2021-01-13. Retrieved 2019-08-25.
 Elman, Jeffrey L. (March 1990). "Finding Structure in Time". Cognitive Science. 14 (2): 179â€“211. doi:10.1207/s15516709cog1402_1. S2CID 2763403.
 Choromanski, Krzysztof; Likhosherstov, Valerii; Dohan, David; Song, Xingyou; Gane, Andreea; Sarlos, Tamas; Hawkins, Peter; Davis, Jared; Mohiuddin, Afroz; Kaiser, Lukasz; Belanger, David; Colwell, Lucy; Weller, Adrian (2020). "Rethinking Attention with Performers". arXiv:2009.14794 [cs.CL].
 Schmidhuber, Juergen (26 March 2021). "26 March 1991: Neural nets learn to program neural nets with fast weightsâ€”the first Transformer variants. 2021-: New stuff!". IDSIA, Switzerland. Archived from the original on 5 Dec 2023. Retrieved 29 Dec 2023.
 Schmidhuber, JÃ¼rgen (1993). "Reducing the ratio between learning complexity and number of time-varying variables in fully recurrent nets". ICANN 1993. Springer. pp. 460â€“463.
 Brown, Peter F. (1993). "The mathematics of statistical machine translation: Parameter estimation". Computational Linguistics (19): 263â€“311.
 Banko, Michele; Brill, Eric (2001). "Scaling to very very large corpora for natural language disambiguation". Proceedings of the 39th Annual Meeting on Association for Computational Linguistics - ACL '01. Morristown, NJ, USA: Association for Computational Linguistics: 26â€“33. doi:10.3115/1073012.1073017. S2CID 6645623.
 Sutskever, Ilya; Vinyals, Oriol; Le, Quoc V (2014). "Sequence to Sequence Learning with Neural Networks". Advances in Neural Information Processing Systems. 27. Curran Associates, Inc. arXiv:1409.3215.
 Cho, Kyunghyun; van Merrienboer, Bart; Bahdanau, Dzmitry; Bengio, Yoshua (2014). "On the Properties of Neural Machine Translation: Encoderâ€“Decoder Approaches". Proceedings of SSST-8, Eighth Workshop on Syntax, Semantics and Structure in Statistical Translation. Stroudsburg, PA, USA: Association for Computational Linguistics: 103â€“111. arXiv:1409.1259. doi:10.3115/v1/w14-4012. S2CID 11336213.
 Chung, Junyoung; Gulcehre, Caglar; Cho, KyungHyun; Bengio, Yoshua (2014). "Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling". arXiv:1412.3555 [cs.NE].
 Gruber, N.; Jockisch, A. (2020), "Are GRU cells more specific and LSTM cells more sensitive in motive classification of text?", Frontiers in Artificial Intelligence, 3: 40, doi:10.3389/frai.2020.00040, PMC 7861254, PMID 33733157, S2CID 220252321
 Bahdanau, Dzmitry; Cho, Kyunghyun; Bengio, Yoshua (2014-09-01). "Neural Machine Translation by Jointly Learning to Align and Translate". arXiv:1409.0473 [cs.CL].
 "Google Scholar". scholar.google.com. Retrieved 2023-08-13.
 Lewis-Kraus, Gideon (2016-12-14). "The Great A.I. Awakening". The New York Times. ISSN 0362-4331. Archived from the original on 24 May 2023. Retrieved 2023-06-22.
 Wu, Yonghui; et al. (2016-09-01). "Google's Neural Machine Translation System: Bridging the Gap between Human and Machine Translation". arXiv:1609.08144 [cs.CL].
 Devlin, Jacob; Chang, Ming-Wei; Lee, Kenton; Toutanova, Kristina (11 October 2018). "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding". arXiv:1810.04805v2 [cs.CL].
 Dosovitskiy, Alexey; Beyer, Lucas; Kolesnikov, Alexander; Weissenborn, Dirk; Zhai, Xiaohua; Unterthiner, Thomas; Dehghani, Mostafa; Minderer, Matthias; Heigold, Georg; Gelly, Sylvain; Uszkoreit, Jakob (2021-06-03). "An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale". arXiv:2010.11929 [cs.CV].
 Gulati, Anmol; Qin, James; Chiu, Chung-Cheng; Parmar, Niki; Zhang, Yu; Yu, Jiahui; Han, Wei; Wang, Shibo; Zhang, Zhengdong; Wu, Yonghui; Pang, Ruoming (2020). "Conformer: Convolution-augmented Transformer for Speech Recognition". arXiv:2005.08100 [eess.AS].
 Xiong, Ruibin; Yang, Yunchang; He, Di; Zheng, Kai; Zheng, Shuxin; Xing, Chen; Zhang, Huishuai; Lan, Yanyan; Wang, Liwei; Liu, Tie-Yan (2020-06-29). "On Layer Normalization in the Transformer Architecture". arXiv:2002.04745 [cs.LG].
 "Improving language understanding with unsupervised learning". openai.com. June 11, 2018. Archived from the original on 2023-03-18. Retrieved 2023-03-18.
 finetune-transformer-lm, OpenAI, June 11, 2018, retrieved 2023-05-01
 "Papers with Code â€“ A Decomposable Attention Model for Natural Language Inference". paperswithcode.com.
 Chen, Jia; Chen, Tao; Shen, Mengqi; Shi, Yunhai; Wang, Dongjing; Zhang, Xin (2022-09-01). "Gated three-tower transformer for text-driven stock market prediction". Multimedia Tools and Applications. 81 (21): 30093â€“30119. doi:10.1007/s11042-022-11908-1. ISSN 1573-7721. S2CID 247987240.
 Raffel, Colin; Shazeer, Noam; Roberts, Adam; Lee, Katherine; Narang, Sharan; Matena, Michael; Zhou, Yanqi; Li, Wei; Liu, Peter J. (2020-01-01). "Exploring the limits of transfer learning with a unified text-to-text transformer". The Journal of Machine Learning Research. 21 (1): 140:5485â€“140:5551. arXiv:1910.10683. ISSN 1532-4435.
 Kariampuzha, William; Alyea, Gioconda; Qu, Sue; Sanjak, Jaleal; MathÃ©, Ewy; Sid, Eric; Chatelaine, Haley; Yadaw, Arjun; Xu, Yanji; Zhu, Qian (2023). "Precision information extraction for rare disease epidemiology at scale". Journal of Translational Medicine. 21 (1): 157. doi:10.1186/s12967-023-04011-y. PMC 9972634. PMID 36855134.
 Assael, Yannis; Sommerschield, Thea; Shillingford, Brendan; Bordbar, Mahyar; Pavlopoulos, John; Chatzipanagiotou, Marita; Androutsopoulos, Ion; Prag, Jonathan; de Freitas, Nando (March 2022). "Restoring and attributing ancient texts using deep neural networks". Nature. 603 (7900): 280â€“283. Bibcode:2022Natur.603..280A. doi:10.1038/s41586-022-04448-z. ISSN 1476-4687. PMC 8907065. PMID 35264762.
 "Sequence Modeling with Neural Networks (Part 2): Attention Models". Indico. 2016-04-18. Archived from the original on 2020-10-21. Retrieved 2019-10-15.
 Alammar, Jay. "The Illustrated Transformer". jalammar.github.io. Archived from the original on 2020-10-18. Retrieved 2019-10-15.
 Clark, Kevin; Khandelwal, Urvashi; Levy, Omer; Manning, Christopher D. (August 2019). "What Does BERT Look at? An Analysis of BERT's Attention". Proceedings of the 2019 ACL Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP. Florence, Italy: Association for Computational Linguistics: 276â€“286. arXiv:1906.04341. doi:10.18653/v1/W19-4828. Archived from the original on 2020-10-21. Retrieved 2020-05-20.
 LeCun, Yann (Apr 28, 2023). "A survey of LLMs with a practical guide and evolutionary tree". Twitter. Archived from the original on 23 Jun 2023. Retrieved 2023-06-23.
 "Masked language modeling". huggingface.co. Retrieved 2023-10-05.
 "Causal language modeling". huggingface.co. Retrieved 2023-10-05.
 Shazeer, Noam (2020-02-01). "GLU Variants Improve Transformer". arXiv:2002.05202 [cs.LG].
 Dufter, Philipp; Schmitt, Martin; SchÃ¼tze, Hinrich (2022-06-06). "Position Information in Transformers: An Overview". Computational Linguistics. 48 (3): 733â€“763. arXiv:2102.11090. doi:10.1162/coli_a_00445. ISSN 0891-2017. S2CID 231986066.
 Su, Jianlin; Lu, Yu; Pan, Shengfeng; Murtadha, Ahmed; Wen, Bo; Liu, Yunfeng (2021-04-01). "RoFormer: Enhanced Transformer with Rotary Position Embedding". arXiv:2104.09864 [cs.CL].
 Press, Ofir; Smith, Noah A.; Lewis, Mike (2021-08-01). "Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation". arXiv:2108.12409 [cs.CL].
 Shaw, Peter; Uszkoreit, Jakob; Vaswani, Ashish (2018). "Self-Attention with Relative Position Representations". arXiv:1803.02155 [cs.CL].
 Dao, Tri; Fu, Dan; Ermon, Stefano; Rudra, Atri; RÃ©, Christopher (2022-12-06). "FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness". Advances in Neural Information Processing Systems. 35: 16344â€“16359. arXiv:2205.14135.
 "Stanford CRFM". crfm.stanford.edu. Retrieved 2023-07-18.
 "FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning". Princeton NLP. 2023-06-17. Retrieved 2023-07-18.
 "Introducing Together AI Chief Scientist Tri Dao, as he releases FlashAttention-2 to speed up model training and inference". TOGETHER. Retrieved 2023-07-18.
 Chowdhery, Aakanksha; Narang, Sharan; Devlin, Jacob; Bosma, Maarten; Mishra, Gaurav; Roberts, Adam; Barham, Paul; Chung, Hyung Won; Sutton, Charles; Gehrmann, Sebastian; Schuh, Parker; Shi, Kensen; Tsvyashchenko, Sasha; Maynez, Joshua; Rao, Abhishek (2022-04-01). "PaLM: Scaling Language Modeling with Pathways". arXiv:2204.02311 [cs.CL].
 Leviathan, Yaniv; Kalman, Matan; Matias, Yossi (2023-05-18), Fast Inference from Transformers via Speculative Decoding, arXiv:2211.17192
 Fu, Yao (2023-12-13). "Towards 100x Speedup: Full Stack Transformer Inference Optimization".
 Chen, Charlie; Borgeaud, Sebastian; Irving, Geoffrey; Lespiau, Jean-Baptiste; Sifre, Laurent; Jumper, John (2023-02-02), Accelerating Large Language Model Decoding with Speculative Sampling, arXiv:2302.01318
 Kitaev, Nikita; Kaiser, Åukasz; Levskaya, Anselm (2020). "Reformer: The Efficient Transformer". arXiv:2001.04451 [cs.LG].
 "Constructing Transformers For Longer Sequences with Sparse Attention Methods". Google AI Blog. 25 March 2021. Archived from the original on 2021-09-18. Retrieved 2021-05-28.
 "Tasks with Long Sequences â€“ Chatbot". Coursera. Archived from the original on 2020-10-26. Retrieved 2020-10-22.
 "Reformer: The Efficient Transformer". Google AI Blog. 16 January 2020. Archived from the original on 2020-10-22. Retrieved 2020-10-22.
 Zhai, Shuangfei; Talbott, Walter; Srivastava, Nitish; Huang, Chen; Goh, Hanlin; Zhang, Ruixiang; Susskind, Josh (2021-09-21). "An Attention Free Transformer". arXiv:2105.14103 [cs.LG].
 Tay, Yi; Dehghani, Mostafa; Abnar, Samira; Shen, Yikang; Bahri, Dara; Pham, Philip; Rao, Jinfeng; Yang, Liu; Ruder, Sebastian; Metzler, Donald (2020-11-08). "Long Range Arena: A Benchmark for Efficient Transformers". arXiv:2011.04006 [cs.LG].
 Peng, Hao; Pappas, Nikolaos; Yogatama, Dani; Schwartz, Roy; Smith, Noah A.; Kong, Lingpeng (2021-03-19). "Random Feature Attention". arXiv:2103.02143 [cs.CL].
 Choromanski, Krzysztof; Likhosherstov, Valerii; Dohan, David; Song, Xingyou; Gane, Andreea; Sarlos, Tamas; Hawkins, Peter; Davis, Jared; Belanger, David; Colwell, Lucy; Weller, Adrian (2020-09-30). "Masked Language Modeling for Proteins via Linearly Scalable Long-Context Transformers". arXiv:2006.03555 [cs.LG].
 Radford, Alec; Kim, Jong Wook; Xu, Tao; Brockman, Greg; McLeavey, Christine; Sutskever, Ilya (2022). "Robust Speech Recognition via Large-Scale Weak Supervision". arXiv:2212.04356 [eess.AS].
 Jaegle, Andrew; Gimeno, Felix; Brock, Andrew; Zisserman, Andrew; Vinyals, Oriol; Carreira, Joao (2021-06-22). "Perceiver: General Perception with Iterative Attention". arXiv:2103.03206 [cs.CV].
 Jaegle, Andrew; Borgeaud, Sebastian; Alayrac, Jean-Baptiste; Doersch, Carl; Ionescu, Catalin; Ding, David; Koppula, Skanda; Zoran, Daniel; Brock, Andrew; Shelhamer, Evan; HÃ©naff, Olivier (2021-08-02). "Perceiver IO: A General Architecture for Structured Inputs & Outputs". arXiv:2107.14795 [cs.LG].
 Peebles, William; Xie, Saining (March 2, 2023). "Scalable Diffusion Models with Transformers". arXiv:2212.09748 [cs.CV].
 "Google AI Unveils Muse, a New Text-to-Image Transformer Model". InfoQ.
 "Using Diffusion Models to Create Superior NeRF Avatars". January 5, 2023.
 Islam, Arham (November 14, 2022). "How Do DALLÂ·E 2, Stable Diffusion, and Midjourney Work?".
Further reading
Hubert Ramsauer et al. (2020), "Hopfield Networks is All You Need" Archived 2021-09-18 at the Wayback Machine, preprint submitted for ICLR 2021. arXiv:2008.02217; see also authors' blog Archived 2021-09-18 at the Wayback Machine
â€“ Discussion of the effect of a transformer layer as equivalent to a Hopfield update, bringing the input closer to one of the fixed points (representable patterns) of a continuous-valued Hopfield network
Alexander Rush, The Annotated transformer Archived 2021-09-22 at the Wayback Machine, Harvard NLP group, 3 April 2018
Phuong, Mary; Hutter, Marcus (2022), Formal Algorithms for Transformers, arXiv:2207.09238
vte
Google AI
vte
Differentiable computing
Categories: Google softwareNeural network architectures
This page was last edited on 9 April 2024, at 09:37 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. WikipediaÂ® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaCode of ConductDevelopersStatisticsCookie statementMobile viewWikimedia FoundationPowered by MediaWiki
